# Redis 版本


- 3.x 版本，单线程
- 4.x 客户端请求单线程，引入多线程的异步删除
- 6.x 多线程石锤

# 为何是单线程的

单线程有一个很大的BUG，大key删除，会形成redis的阻塞，不得不引入多线程，惰性删除

单线程的优势：
1. 瓶颈在于内存或者网络，而不是CPU
2. 多线程复杂度远大于单线程
3. 即使使用单线程模型也并发的处理多客户端的请求，主要使用的是多路复用和非阻塞IO；


## bitmap
底层是String类型，使用get 命令获取时获取到的是ASCII码，每8位
为一个单位，默认是8位，超过8位自动扩容

+ 应用场景: 日历打卡，每个用户按照月存储打卡数据
```shell
# user 1 用户，15号进行了打卡
setbit user:1 15 1
```

## 缓存穿透
没过redis直接穿透到mysql（一直查询没有的数据）恶意攻击

解决：布隆过滤器，空对象缓存

## 缓存击穿

打到了redis上，但是没有打中，就打到了mysql上（热点KEY突然失效）

解决: 
+ 差异化失效时间
+ 互斥更新
+ 随机退避，失效时随机sleep一个很短的时间，再次查询，如果失败再执行更新
+ 热点Key不设置过期时间

## 缓存雪崩
缓存挂掉

+ 事前：redis主从、哨兵
+ 事中：本地缓存 ecache，阿里seleth熔断
+ 事后：redis aof、reb？回滚


## 缓存更新方式
+ 同步更新
+ 失效更新
+ 异步更新
+ 定时更新

## 缓存不一致
产生原因：同步更新失败、异步更新导致不一致

+ 增加重试
+ 补偿任务
+ 最终一致

## redis 分布式锁
从JVM的锁看到分布式锁

## 删除策略
3种删除策略，8种淘汰策略

1. 立刻（对内存友好，CPU不友好）
2. 惰性（对CPU不友好，对内存友好）
3. 定期
   随机抽查key


# 为啥快？

极致的压缩内存空间，抛弃C的string 用自己的sds进行string存储


## string
1. int
2. emstr 源码中，连续的内存空间，减少内存碎片，指针就比原有的+1
3. raw 新的内存空间

对于embstr 如果采用 append 命令，encoding会变成raw

## hashtable
1. ziplist
2. hashtable